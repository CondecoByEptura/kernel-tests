{
  "comments": [
    {
      "key": {
        "uuid": "e1492c4f_f77c2778",
        "filename": "net/test/xfrm.py",
        "patchSetId": 2
      },
      "lineNbr": 289,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2017-05-12T02:03:53Z",
      "side": 1,
      "message": "Consistency would suggest using \\x00, but either is fine.",
      "range": {
        "startLine": 289,
        "startChar": 4,
        "endLine": 289,
        "endChar": 66
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "386d393c_69d62564",
        "filename": "net/test/xfrm.py",
        "patchSetId": 2
      },
      "lineNbr": 289,
      "author": {
        "id": 1070023
      },
      "writtenOn": "2017-05-12T17:21:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e1492c4f_f77c2778",
      "range": {
        "startLine": 289,
        "startChar": 4,
        "endLine": 289,
        "endChar": 66
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d891755_abe619d6",
        "filename": "net/test/xfrm.py",
        "patchSetId": 2
      },
      "lineNbr": 309,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2017-05-12T02:03:53Z",
      "side": 1,
      "message": "Given that this is only used in test code I don\u0027t think it is necessary to check for the kernel incorrectly returning an error of 0, or returning the wrong type. If it does, then the test will fail.\n\nSo I\u0027d just do:\n\n    if nl_hdr.type \u003d\u003d netlink.NLMSG_ERROR:\n      error \u003d netlink.NLMsgErr(data).error\n    else:\n      return XfrmUsersaInfo(data)\n\nor:\n\n    if nl_hdr.type \u003d\u003d netlink.NLMSG_ERROR:\n      error \u003d netlink.NLMsgErr(data).error\n    elif nl_hdr.type \u003d\u003d XFRM_MSG_NEWSA:\n      return XfrmUsersaInfo(data)\n    else:\n      raise ValueError(\u0027Unexpected netlink message type: %d\u0027 % nl_hdr.type)",
      "range": {
        "startLine": 302,
        "startChar": 0,
        "endLine": 309,
        "endChar": 63
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6fadb63a_ccf612aa",
        "filename": "net/test/xfrm.py",
        "patchSetId": 2
      },
      "lineNbr": 309,
      "author": {
        "id": 1070023
      },
      "writtenOn": "2017-05-12T17:21:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2d891755_abe619d6",
      "range": {
        "startLine": 302,
        "startChar": 0,
        "endLine": 309,
        "endChar": 63
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "95811da5_04350327",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 2
      },
      "lineNbr": 322,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2017-05-12T02:03:53Z",
      "side": 1,
      "message": "If you run the test twice in a row, will it fail with EEXIST? If so, suggest cleaning up. Something like:\n\n    new_sa \u003d self.xfrm.AllocSpi(\"::\", IPPROTO_ESP, spi, spi)\n    try:\n      self.assertEquals(spi, ntohl(new_sa.id.spi))\n    finally:\n      self.xfrm.DelSa(...)  # or however it is that we delete one of these.\n\nIf you\u0027re going to end up doing this in multiple tests, you could put the cleanup code into tearDown. You could have the testcases maintain a list of all the SPIs they\u0027ve created in a new class variable, and when tearDown runs, it could just delete all of them.",
      "range": {
        "startLine": 322,
        "startChar": 4,
        "endLine": 322,
        "endChar": 48
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd4d0769_57aaf5dd",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 2
      },
      "lineNbr": 322,
      "author": {
        "id": 1070023
      },
      "writtenOn": "2017-05-12T17:21:04Z",
      "side": 1,
      "message": "The test doesn\u0027t fail because setUp currently flushes ip xfrm state before the test runs. You just merged a change that flushes in both setUp and tearDown - would you consider that to be sufficient cleanup, or would you rather see tests explicitly clear their state?\n\nI\u0027ve seen the pattern elsewhere where tearDown will flush state, but also fail the test if it didn\u0027t clean up after itself.\n\n\nOn a side note, testAllocSpecificSpiUnavailable tries to alloc the same SPI twice in a row and asserts ENOENT is raised as expected.",
      "parentUuid": "95811da5_04350327",
      "range": {
        "startLine": 322,
        "startChar": 4,
        "endLine": 322,
        "endChar": 48
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e170aa7_aa5e44ca",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 2
      },
      "lineNbr": 322,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2017-05-13T06:26:35Z",
      "side": 1,
      "message": "Ack. This is fine for now.\n\nWhen we start running these tests on actual devices this will be a problem because we\u0027ll be interfering with existing XFRM state on the device.\n\nAny thoughts on how we\u0027d make these tests more friendly to the presence of existing XFRM state? Is there something we can put into the SAs and policies we create, such that we would then only flush SAs that we knew we had created ourselves?",
      "parentUuid": "cd4d0769_57aaf5dd",
      "range": {
        "startLine": 322,
        "startChar": 4,
        "endLine": 322,
        "endChar": 48
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}