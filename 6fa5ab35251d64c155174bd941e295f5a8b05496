{
  "comments": [
    {
      "key": {
        "uuid": "e1492c4f_f77c2778",
        "filename": "net/test/xfrm.py",
        "patchSetId": 2
      },
      "lineNbr": 289,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2017-05-12T02:03:53Z",
      "side": 1,
      "message": "Consistency would suggest using \\x00, but either is fine.",
      "range": {
        "startLine": 289,
        "startChar": 4,
        "endLine": 289,
        "endChar": 66
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d891755_abe619d6",
        "filename": "net/test/xfrm.py",
        "patchSetId": 2
      },
      "lineNbr": 309,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2017-05-12T02:03:53Z",
      "side": 1,
      "message": "Given that this is only used in test code I don\u0027t think it is necessary to check for the kernel incorrectly returning an error of 0, or returning the wrong type. If it does, then the test will fail.\n\nSo I\u0027d just do:\n\n    if nl_hdr.type \u003d\u003d netlink.NLMSG_ERROR:\n      error \u003d netlink.NLMsgErr(data).error\n    else:\n      return XfrmUsersaInfo(data)\n\nor:\n\n    if nl_hdr.type \u003d\u003d netlink.NLMSG_ERROR:\n      error \u003d netlink.NLMsgErr(data).error\n    elif nl_hdr.type \u003d\u003d XFRM_MSG_NEWSA:\n      return XfrmUsersaInfo(data)\n    else:\n      raise ValueError(\u0027Unexpected netlink message type: %d\u0027 % nl_hdr.type)",
      "range": {
        "startLine": 302,
        "startChar": 0,
        "endLine": 309,
        "endChar": 63
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "95811da5_04350327",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 2
      },
      "lineNbr": 322,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2017-05-12T02:03:53Z",
      "side": 1,
      "message": "If you run the test twice in a row, will it fail with EEXIST? If so, suggest cleaning up. Something like:\n\n    new_sa \u003d self.xfrm.AllocSpi(\"::\", IPPROTO_ESP, spi, spi)\n    try:\n      self.assertEquals(spi, ntohl(new_sa.id.spi))\n    finally:\n      self.xfrm.DelSa(...)  # or however it is that we delete one of these.\n\nIf you\u0027re going to end up doing this in multiple tests, you could put the cleanup code into tearDown. You could have the testcases maintain a list of all the SPIs they\u0027ve created in a new class variable, and when tearDown runs, it could just delete all of them.",
      "range": {
        "startLine": 322,
        "startChar": 4,
        "endLine": 322,
        "endChar": 48
      },
      "revId": "6fa5ab35251d64c155174bd941e295f5a8b05496",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}