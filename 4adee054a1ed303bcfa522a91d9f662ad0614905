{
  "comments": [
    {
      "key": {
        "uuid": "d19436fa_11ad5e36",
        "filename": "net/test/xfrm.py",
        "patchSetId": 4
      },
      "lineNbr": 173,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "Shouldn\u0027t be needed anymore.",
      "range": {
        "startLine": 173,
        "startChar": 0,
        "endLine": 173,
        "endChar": 57
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f85c355_ff15e554",
        "filename": "net/test/xfrm.py",
        "patchSetId": 4
      },
      "lineNbr": 255,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "For consistency\u0027s sake, IMO it would be nice to just define a single-element struct for this. Then we don\u0027t need 2 libraries and all the code is tidily parallel. Strictly not needed, but mixing struct and cstruct is just the pits.",
      "range": {
        "startLine": 255,
        "startChar": 13,
        "endLine": 255,
        "endChar": 45
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d605ea6_84c96587",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 45,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "Looks like this address is being reused. it\u0027s also TEST_ADDR1.",
      "range": {
        "startLine": 45,
        "startChar": 0,
        "endLine": 45,
        "endChar": 45
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f64fe266_757ede77",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 59,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "This is pretty brittle. I ran in to the same problem in my test. Rather than checking the length, I checked that the destination address is different. There\u0027s an Assert() function you asked me to create, which now provides both options. I suggest we use it, and if you really want to validate the length... that might be a good place to do it.",
      "range": {
        "startLine": 57,
        "startChar": 0,
        "endLine": 59,
        "endChar": 33
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "287e4596_d71bf289",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 78,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "This function was augmented (at your request) and moved to xfrm_base.",
      "range": {
        "startLine": 78,
        "startChar": 6,
        "endLine": 78,
        "endChar": 23
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "402c72b8_0a827433",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 191,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "Tests for V4?",
      "range": {
        "startLine": 191,
        "startChar": 27,
        "endLine": 191,
        "endChar": 28
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "81ef2eb0_31a925a2",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 389,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "Since we\u0027re not planning on using persocket policies for tunnel mode, does it make sense to test a tunnel in that fashion?",
      "range": {
        "startLine": 388,
        "startChar": 0,
        "endLine": 389,
        "endChar": 65
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a8dd948_62240073",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 389,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "having this be an array of addresses is rather surprising, especially given that it\u0027s an array of exactly 2 elements and order matters. Suggest 2 separate named parameters.",
      "range": {
        "startLine": 389,
        "startChar": 42,
        "endLine": 389,
        "endChar": 51
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0cb10871_bf39ea9c",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 393,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "missing \"s\"",
      "range": {
        "startLine": 393,
        "startChar": 5,
        "endLine": 393,
        "endChar": 16
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "073c75c7_1a1d8e2b",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 415,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "Can we use the nifty dict-version?",
      "range": {
        "startLine": 409,
        "startChar": 35,
        "endLine": 415,
        "endChar": 59
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fd6353f3_5e22431b",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 426,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "Must the socket be connected? That seems like a rather unnecessary sequence dependent hoop. If that\u0027s truly needed, then should we document it? Otherwise, can we remove that dependency?",
      "range": {
        "startLine": 426,
        "startChar": 31,
        "endLine": 426,
        "endChar": 49
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aec190d9_c88593e7",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 436,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "can we use the dict versions?",
      "range": {
        "startLine": 431,
        "startChar": 30,
        "endLine": 436,
        "endChar": 44
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0c162438_dd951df4",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 462,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "As per your request, there is now/soon a lookup for this. You can rebase and use it.",
      "range": {
        "startLine": 462,
        "startChar": 4,
        "endLine": 462,
        "endChar": 47
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e5c517e0_71077a3a",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 464,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "soon we shouldn\u0027t need to write this every time we want a random netid. Hopefully you can rebase.",
      "range": {
        "startLine": 464,
        "startChar": 28,
        "endLine": 464,
        "endChar": 54
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "082ac9cd_eb883560",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 473,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "related but not the same? perhaps we should define a relationship like this and start using it consistently?",
      "range": {
        "startLine": 473,
        "startChar": 10,
        "endLine": 473,
        "endChar": 33
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d670aff7_25120f44",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 474,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "define and re-use?",
      "range": {
        "startLine": 474,
        "startChar": 12,
        "endLine": 474,
        "endChar": 21
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "79d38942_fe8a81d5",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 488,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "less change if the lookup is obfuscated within a function that can be made smarter as time progresses.",
      "range": {
        "startLine": 487,
        "startChar": 4,
        "endLine": 488,
        "endChar": 57
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f57347fe_d7e78d89",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 498,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "Still not clear to me why we do this for all netids. It seems like what we would want is to try combinations of differing source and destinations.",
      "range": {
        "startLine": 498,
        "startChar": 4,
        "endLine": 498,
        "endChar": 29
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb89df36_d6c76592",
        "filename": "net/test/xfrm_test.py",
        "patchSetId": 4
      },
      "lineNbr": 499,
      "author": {
        "id": 1060151
      },
      "writtenOn": "2017-10-10T02:20:13Z",
      "side": 1,
      "message": "It looks to me like in these tests the source and destination netid are always the same. Is that intended? More interestingly, since the socket\u0027s netId is random... some % of the time this will be the same netid as well? Something doesn\u0027t make sense to me. Maybe I\u0027m reading it wrong. :-/",
      "range": {
        "startLine": 499,
        "startChar": 48,
        "endLine": 499,
        "endChar": 61
      },
      "revId": "4adee054a1ed303bcfa522a91d9f662ad0614905",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}