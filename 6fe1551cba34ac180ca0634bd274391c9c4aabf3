{
  "comments": [
    {
      "key": {
        "uuid": "8302886c_070c6e80",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2018-01-04T04:32:46Z",
      "side": 1,
      "message": "I don\u0027t think it\u0027s a good idea to require the callers to know about block lengths here - it\u0027s not something they\u0027re likely to know (and in fact, in this CL no caller knows them). Instead of having the parameters be block lengths, can we have the callers pass the algorithms themselves (let\u0027s say one for each of crypt, auth and AEAD)? Those should have enough information to calculate all these values, right?",
      "range": {
        "startLine": 141,
        "startChar": 0,
        "endLine": 143,
        "endChar": 58
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1fe0c7c0_c165e4d6",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 1221725
      },
      "writtenOn": "2018-01-04T22:16:53Z",
      "side": 1,
      "message": "Unfortunately the algorithms themselves don\u0027t have block sizes or lengths (for CBC, they\u0027re defined in RFC 3602, and are never passed down); the only one I would be able to extract here is the truncation length, but that would mean having the crypt arguments as size constants, while the authentication argument would be an algorithm.",
      "parentUuid": "8302886c_070c6e80",
      "range": {
        "startLine": 141,
        "startChar": 0,
        "endLine": 143,
        "endChar": 58
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb351c47_d6f7c925",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2018-01-09T14:41:22Z",
      "side": 1,
      "message": "What I meant was - we don\u0027t ever pass block sizes to the kernel, right? We pass it algorithm names and key sizes, and possibly truncation lengths. From those, the kernel is able to determine the block size. Any reason we can\u0027t do the same here?\n\nThe constants we use in this file to describe algorithm parameters (e.g., _ALGO_AUTH_NULL, _ALGO_HMAC_SHA1, _ALGO_CRYPT_NULL, and _ALGO_CBC_AES_256) should all contain enough information to calculate the block sizes. So all we\u0027d need is a method that takes one of those tuples and returns a block size.",
      "parentUuid": "1fe0c7c0_c165e4d6",
      "range": {
        "startLine": 141,
        "startChar": 0,
        "endLine": 143,
        "endChar": 58
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42588dd3_1a886266",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 1221725
      },
      "writtenOn": "2018-01-09T19:13:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "eb351c47_d6f7c925",
      "range": {
        "startLine": 141,
        "startChar": 0,
        "endLine": 143,
        "endChar": 58
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35549edc_707ed2b7",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 164,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2018-01-04T04:32:46Z",
      "side": 1,
      "message": "len(xfrm.EspHdr)",
      "range": {
        "startLine": 164,
        "startChar": 16,
        "endLine": 164,
        "endChar": 40
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26cfb40a_56dd7cfc",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 164,
      "author": {
        "id": 1221725
      },
      "writtenOn": "2018-01-04T22:16:53Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "35549edc_707ed2b7",
      "range": {
        "startLine": 164,
        "startChar": 16,
        "endLine": 164,
        "endChar": 40
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4fd23df2_c85f6171",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 171,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2018-01-04T04:32:46Z",
      "side": 1,
      "message": "Suggest mentioning that this is one byte pad length and one byte next header.",
      "range": {
        "startLine": 171,
        "startChar": 19,
        "endLine": 171,
        "endChar": 0
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "27b5f1d1_d6c9d56c",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 171,
      "author": {
        "id": 1221725
      },
      "writtenOn": "2018-01-04T22:16:53Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4fd23df2_c85f6171",
      "range": {
        "startLine": 171,
        "startChar": 19,
        "endLine": 171,
        "endChar": 0
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dd8d4e17_2bec1301",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 175,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2018-01-04T04:32:46Z",
      "side": 1,
      "message": "It looks like we do something similar when calculating esplen in EncryptPacketWithNull below. We also do something like this in netlink.PaddedLength. Is enough commonality between the callers that we can factor this out to a simple method with a descriptive name, and have that method be in net_test.py for all to use?",
      "range": {
        "startLine": 175,
        "startChar": 17,
        "endLine": 175,
        "endChar": 83
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ecfa18b3_14fe61e5",
        "filename": "net/test/xfrm_base.py",
        "patchSetId": 1
      },
      "lineNbr": 175,
      "author": {
        "id": 1221725
      },
      "writtenOn": "2018-01-04T22:16:53Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dd8d4e17_2bec1301",
      "range": {
        "startLine": 175,
        "startChar": 17,
        "endLine": 175,
        "endChar": 83
      },
      "revId": "6fe1551cba34ac180ca0634bd274391c9c4aabf3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}